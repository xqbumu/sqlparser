/*
Copyright 2021 The Vitess Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
// Code generated by Sizegen. DO NOT EDIT.

package sqlparser

import (
	"math"
	"reflect"
	"unsafe"

	hack "github.com/xqbumu/sqlparser/dependency/hack"
)

type cachedObject interface {
	CachedSize(alloc bool) int64
}

func (cached *AddColumns) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Columns []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	// field After *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.After.CachedSize(true)
	return size
}
func (cached *AddConstraintDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field ConstraintDefinition *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ConstraintDefinition
	size += cached.ConstraintDefinition.CachedSize(true)
	return size
}
func (cached *AddIndexDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field IndexDefinition *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IndexDefinition
	size += cached.IndexDefinition.CachedSize(true)
	return size
}
func (cached *AliasedExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field As github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.As.CachedSize(false)
	return size
}
func (cached *AliasedTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SimpleTableExpr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Partitions github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Partitions)) * int64(32))
		for _, elem := range cached.Partitions {
			size += elem.CachedSize(false)
		}
	}
	// field As github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.As.CachedSize(false)
	// field Hints github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IndexHints
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Hints)) * int64(8))
		for _, elem := range cached.Hints {
			size += elem.CachedSize(true)
		}
	}
	// field Columns github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(32))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *AlterCharset) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field CharacterSet string
	size += hack.RuntimeAllocSize(int64(len(cached.CharacterSet)))
	// field Collate string
	size += hack.RuntimeAllocSize(int64(len(cached.Collate)))
	return size
}
func (cached *AlterCheck) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *AlterColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Column *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.Column.CachedSize(true)
	// field DefaultVal github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.DefaultVal.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Invisible *bool
	size += hack.RuntimeAllocSize(int64(1))
	return size
}
func (cached *AlterDatabase) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field DBName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.DBName.CachedSize(false)
	// field AlterOptions []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.DatabaseOption
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.AlterOptions)) * int64(24))
		for _, elem := range cached.AlterOptions {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *AlterIndex) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *AlterMigration) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field UUID string
	size += hack.RuntimeAllocSize(int64(len(cached.UUID)))
	// field Expire string
	size += hack.RuntimeAllocSize(int64(len(cached.Expire)))
	// field Ratio *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Ratio.CachedSize(true)
	return size
}
func (cached *AlterTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field AlterOptions []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.AlterOption
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.AlterOptions)) * int64(16))
		for _, elem := range cached.AlterOptions {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field PartitionSpec *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionSpec
	size += cached.PartitionSpec.CachedSize(true)
	// field PartitionOption *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionOption
	size += cached.PartitionOption.CachedSize(true)
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *AlterView) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(144)
	}
	// field ViewName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.ViewName.CachedSize(false)
	// field Algorithm string
	size += hack.RuntimeAllocSize(int64(len(cached.Algorithm)))
	// field Definer *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Definer
	size += cached.Definer.CachedSize(true)
	// field Security string
	size += hack.RuntimeAllocSize(int64(len(cached.Security)))
	// field Columns github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(32))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Select github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field CheckOption string
	size += hack.RuntimeAllocSize(int64(len(cached.CheckOption)))
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *AlterVschema) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field VindexSpec *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.VindexSpec
	size += cached.VindexSpec.CachedSize(true)
	// field VindexCols []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.VindexCols)) * int64(32))
		for _, elem := range cached.VindexCols {
			size += elem.CachedSize(false)
		}
	}
	// field AutoIncSpec *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.AutoIncSpec
	size += cached.AutoIncSpec.CachedSize(true)
	return size
}
func (cached *AndExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ArgumentLessWindowExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field OverClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OverClause
	size += cached.OverClause.CachedSize(true)
	return size
}
func (cached *AutoIncSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Column github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Column.CachedSize(false)
	// field Sequence github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Sequence.CachedSize(false)
	return size
}
func (cached *Avg) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *BetweenExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field From github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.From.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field To github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.To.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *BinaryExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *BindVarNeeds) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field NeedFunctionResult []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.NeedFunctionResult)) * int64(16))
		for _, elem := range cached.NeedFunctionResult {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field NeedSystemVariable []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.NeedSystemVariable)) * int64(16))
		for _, elem := range cached.NeedSystemVariable {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field NeedUserDefinedVariables []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.NeedUserDefinedVariables)) * int64(16))
		for _, elem := range cached.NeedUserDefinedVariables {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *BitAnd) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *BitOr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *BitXor) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *CallProc) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Name.CachedSize(false)
	// field Params github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Params)) * int64(16))
		for _, elem := range cached.Params {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *CaseExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Whens []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.When
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Whens)) * int64(8))
		for _, elem := range cached.Whens {
			size += elem.CachedSize(true)
		}
	}
	// field Else github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Else.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *CastExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Type *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ConvertType
	size += cached.Type.CachedSize(true)
	return size
}
func (cached *ChangeColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field OldColumn *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.OldColumn.CachedSize(true)
	// field NewColDefinition *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnDefinition
	size += cached.NewColDefinition.CachedSize(true)
	// field After *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.After.CachedSize(true)
	return size
}
func (cached *CharExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Exprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Charset string
	size += hack.RuntimeAllocSize(int64(len(cached.Charset)))
	return size
}
func (cached *CheckConstraintDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ColName) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Qualifier github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Qualifier.CachedSize(false)
	return size
}
func (cached *CollateExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Collation string
	size += hack.RuntimeAllocSize(int64(len(cached.Collation)))
	return size
}
func (cached *ColumnCharset) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	return size
}
func (cached *ColumnDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(128)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Type github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnType
	size += cached.Type.CachedSize(false)
	return size
}
func (cached *ColumnType) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	// field Options *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnTypeOptions
	size += cached.Options.CachedSize(true)
	// field Length *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Length.CachedSize(true)
	// field Scale *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Scale.CachedSize(true)
	// field Charset github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnCharset
	size += cached.Charset.CachedSize(false)
	// field EnumValues []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.EnumValues)) * int64(16))
		for _, elem := range cached.EnumValues {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *ColumnTypeOptions) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(160)
	}
	// field Null *bool
	size += hack.RuntimeAllocSize(int64(1))
	// field Default github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Default.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OnUpdate github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.OnUpdate.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field As github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.As.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Comment *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Comment.CachedSize(true)
	// field Collate string
	size += hack.RuntimeAllocSize(int64(len(cached.Collate)))
	// field Reference *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ReferenceDefinition
	size += cached.Reference.CachedSize(true)
	// field Invisible *bool
	size += hack.RuntimeAllocSize(int64(1))
	// field EngineAttribute *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.EngineAttribute.CachedSize(true)
	// field SecondaryEngineAttribute *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.SecondaryEngineAttribute.CachedSize(true)
	// field SRID *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.SRID.CachedSize(true)
	return size
}
func (cached *CommentOnly) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Comments []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *CommonTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field ID github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.ID.CachedSize(false)
	// field Columns github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(32))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Subquery *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Subquery
	size += cached.Subquery.CachedSize(true)
	return size
}
func (cached *ComparisonExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Escape github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Escape.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ConstraintDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Details github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ConstraintInfo
	if cc, ok := cached.Details.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ConvertExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Type *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ConvertType
	size += cached.Type.CachedSize(true)
	return size
}
func (cached *ConvertType) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	// field Length *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Length.CachedSize(true)
	// field Scale *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Scale.CachedSize(true)
	// field Charset github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnCharset
	size += cached.Charset.CachedSize(false)
	return size
}
func (cached *ConvertUsingExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	return size
}
func (cached *Count) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Args github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Args)) * int64(16))
		for _, elem := range cached.Args {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *CreateDatabase) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field DBName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.DBName.CachedSize(false)
	// field CreateOptions []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.DatabaseOption
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.CreateOptions)) * int64(24))
		for _, elem := range cached.CreateOptions {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *CreateTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field TableSpec *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableSpec
	size += cached.TableSpec.CachedSize(true)
	// field OptLike *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OptLike
	size += cached.OptLike.CachedSize(true)
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *CreateView) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(144)
	}
	// field ViewName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.ViewName.CachedSize(false)
	// field Algorithm string
	size += hack.RuntimeAllocSize(int64(len(cached.Algorithm)))
	// field Definer *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Definer
	size += cached.Definer.CachedSize(true)
	// field Security string
	size += hack.RuntimeAllocSize(int64(len(cached.Security)))
	// field Columns github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(32))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Select github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field CheckOption string
	size += hack.RuntimeAllocSize(int64(len(cached.CheckOption)))
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *CurTimeFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Fsp github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Fsp.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *DatabaseOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Value string
	size += hack.RuntimeAllocSize(int64(len(cached.Value)))
	return size
}
func (cached *DeallocateStmt) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *Default) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field ColName string
	size += hack.RuntimeAllocSize(int64(len(cached.ColName)))
	return size
}
func (cached *Definer) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	// field Address string
	size += hack.RuntimeAllocSize(int64(len(cached.Address)))
	return size
}
func (cached *Delete) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(144)
	}
	// field With *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.With
	size += cached.With.CachedSize(true)
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field Targets github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Targets)) * int64(32))
		for _, elem := range cached.Targets {
			size += elem.CachedSize(false)
		}
	}
	// field TableExprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TableExprs)) * int64(16))
		for _, elem := range cached.TableExprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Partitions github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Partitions)) * int64(32))
		for _, elem := range cached.Partitions {
			size += elem.CachedSize(false)
		}
	}
	// field Where *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field OrderBy github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Limit *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *DerivedTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Select github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *DropColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field Name *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.Name.CachedSize(true)
	return size
}
func (cached *DropDatabase) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field DBName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.DBName.CachedSize(false)
	return size
}
func (cached *DropKey) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *DropTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field FromTables github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.FromTables)) * int64(32))
		for _, elem := range cached.FromTables {
			size += elem.CachedSize(false)
		}
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *DropView) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field FromTables github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.FromTables)) * int64(32))
		for _, elem := range cached.FromTables {
			size += elem.CachedSize(false)
		}
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *ExecuteStmt) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field Arguments []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Variable
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Arguments)) * int64(8))
		for _, elem := range cached.Arguments {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *ExistsExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field Subquery *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Subquery
	size += cached.Subquery.CachedSize(true)
	return size
}
func (cached *ExplainStmt) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Statement github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Statement
	if cc, ok := cached.Statement.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ExplainTab) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field Wild string
	size += hack.RuntimeAllocSize(int64(len(cached.Wild)))
	return size
}
func (cached *ExtractFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ExtractValueExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Fragment github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Fragment.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field XPathExpr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.XPathExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ExtractedSubquery) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Original github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Original.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Subquery *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Subquery
	size += cached.Subquery.CachedSize(true)
	// field OtherSide github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.OtherSide.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field hasValuesArg string
	size += hack.RuntimeAllocSize(int64(len(cached.hasValuesArg)))
	// field argName string
	size += hack.RuntimeAllocSize(int64(len(cached.argName)))
	// field alternative github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.alternative.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *FirstOrLastValueExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field NullTreatmentClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.NullTreatmentClause
	if cached.NullTreatmentClause != nil {
		size += hack.RuntimeAllocSize(int64(1))
	}
	// field OverClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OverClause
	size += cached.OverClause.CachedSize(true)
	return size
}
func (cached *Flush) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field FlushOptions []string
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.FlushOptions)) * int64(16))
		for _, elem := range cached.FlushOptions {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field TableNames github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TableNames)) * int64(32))
		for _, elem := range cached.TableNames {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *ForeignKeyDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Source github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Source)) * int64(32))
		for _, elem := range cached.Source {
			size += elem.CachedSize(false)
		}
	}
	// field IndexName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.IndexName.CachedSize(false)
	// field ReferenceDefinition *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ReferenceDefinition
	size += cached.ReferenceDefinition.CachedSize(true)
	return size
}
func (cached *FrameClause) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Start *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.FramePoint
	size += cached.Start.CachedSize(true)
	// field End *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.FramePoint
	size += cached.End.CachedSize(true)
	return size
}
func (cached *FramePoint) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *FuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Qualifier github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.Qualifier.CachedSize(false)
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Exprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *GTIDFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Set1 github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Set1.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Set2 github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Set2.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Timeout github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Timeout.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Channel github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Channel.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *GroupConcatExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Exprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field OrderBy github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Separator string
	size += hack.RuntimeAllocSize(int64(len(cached.Separator)))
	// field Limit *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *IdentifierCI) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field val string
	size += hack.RuntimeAllocSize(int64(len(cached.val)))
	// field lowered string
	size += hack.RuntimeAllocSize(int64(len(cached.lowered)))
	return size
}
func (cached *IdentifierCS) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field v string
	size += hack.RuntimeAllocSize(int64(len(cached.v)))
	return size
}
func (cached *IndexColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Column github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Column.CachedSize(false)
	// field Length *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Length.CachedSize(true)
	// field Expression github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expression.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *IndexDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Info *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IndexInfo
	size += cached.Info.CachedSize(true)
	// field Columns []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IndexColumn
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	// field Options []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IndexOption
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Options)) * int64(8))
		for _, elem := range cached.Options {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *IndexHint) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Indexes []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Indexes)) * int64(32))
		for _, elem := range cached.Indexes {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *IndexInfo) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Type string
	size += hack.RuntimeAllocSize(int64(len(cached.Type)))
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field ConstraintName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.ConstraintName.CachedSize(false)
	return size
}
func (cached *IndexOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	// field Value *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Value.CachedSize(true)
	// field String string
	size += hack.RuntimeAllocSize(int64(len(cached.String)))
	return size
}
func (cached *Insert) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(144)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field Partitions github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Partitions)) * int64(32))
		for _, elem := range cached.Partitions {
			size += elem.CachedSize(false)
		}
	}
	// field Columns github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(32))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(false)
		}
	}
	// field Rows github.com/xqbumu/sqlparser/dependency/vt/sqlparser.InsertRows
	if cc, ok := cached.Rows.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OnDup github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OnDup
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OnDup)) * int64(8))
		for _, elem := range cached.OnDup {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *InsertExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Str github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Str.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Pos github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Pos.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Len github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Len.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field NewStr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.NewStr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *IntervalExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Unit string
	size += hack.RuntimeAllocSize(int64(len(cached.Unit)))
	return size
}
func (cached *IntervalFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Exprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *IntroducerExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field CharacterSet string
	size += hack.RuntimeAllocSize(int64(len(cached.CharacterSet)))
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *IsExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONArrayExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Params github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Params)) * int64(16))
		for _, elem := range cached.Params {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *JSONAttributesExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Path github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Path.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONContainsExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Target github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Target.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Candidate github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Candidate.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field PathList []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.PathList)) * int64(16))
		for _, elem := range cached.PathList {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *JSONContainsPathExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OneOrAll github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.OneOrAll.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field PathList []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.PathList)) * int64(16))
		for _, elem := range cached.PathList {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *JSONExtractExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field PathList []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.PathList)) * int64(16))
		for _, elem := range cached.PathList {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *JSONKeysExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Path github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Path.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONObjectExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Params []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JSONObjectParam
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Params)) * int64(8))
		for _, elem := range cached.Params {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *JSONObjectParam) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Key github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Key.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Value github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Value.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONOverlapsExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field JSONDoc1 github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc1.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field JSONDoc2 github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc2.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONPrettyExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field JSONVal github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONVal.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONQuoteExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field StringArg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.StringArg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONRemoveExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field PathList github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.PathList)) * int64(16))
		for _, elem := range cached.PathList {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *JSONSchemaValidFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Schema github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Schema.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Document github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Document.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONSchemaValidationReportFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Schema github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Schema.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Document github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Document.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONSearchExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OneOrAll github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.OneOrAll.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field SearchStr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.SearchStr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field EscapeChar github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.EscapeChar.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field PathList []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.PathList)) * int64(16))
		for _, elem := range cached.PathList {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *JSONStorageFreeExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field JSONVal github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONVal.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONStorageSizeExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field JSONVal github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONVal.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Alias github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.Alias.CachedSize(false)
	// field Filter github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Filter.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Columns []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtColumnDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *JSONUnquoteExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field JSONValue github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONValue.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JSONValueExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Path github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Path.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field ReturningType *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ConvertType
	size += cached.ReturningType.CachedSize(true)
	// field EmptyOnResponse *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtOnResponse
	size += cached.EmptyOnResponse.CachedSize(true)
	// field ErrorOnResponse *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtOnResponse
	size += cached.ErrorOnResponse.CachedSize(true)
	return size
}
func (cached *JSONValueMergeExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field JSONDocList github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.JSONDocList)) * int64(16))
		for _, elem := range cached.JSONDocList {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *JSONValueModifierExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field JSONDoc github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONDoc.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Params []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JSONObjectParam
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Params)) * int64(8))
		for _, elem := range cached.Params {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *JoinCondition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field On github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.On.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Using github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Using)) * int64(32))
		for _, elem := range cached.Using {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *JoinTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field LeftExpr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableExpr
	if cc, ok := cached.LeftExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field RightExpr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableExpr
	if cc, ok := cached.RightExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Condition *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JoinCondition
	size += cached.Condition.CachedSize(true)
	return size
}
func (cached *JtColumnDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field JtOrdinal *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtOrdinalColDef
	size += cached.JtOrdinal.CachedSize(true)
	// field JtPath *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtPathColDef
	size += cached.JtPath.CachedSize(true)
	// field JtNestedPath *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtNestedPathColDef
	size += cached.JtNestedPath.CachedSize(true)
	return size
}
func (cached *JtNestedPathColDef) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Path github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Path.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Columns []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtColumnDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *JtOnResponse) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *JtOrdinalColDef) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *JtPathColDef) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(176)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Type github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnType
	size += cached.Type.CachedSize(false)
	// field Path github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Path.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field EmptyOnResponse *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtOnResponse
	size += cached.EmptyOnResponse.CachedSize(true)
	// field ErrorOnResponse *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.JtOnResponse
	size += cached.ErrorOnResponse.CachedSize(true)
	return size
}
func (cached *KeyState) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *LagLeadExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field N github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.N.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Default github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Default.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OverClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OverClause
	size += cached.OverClause.CachedSize(true)
	// field NullTreatmentClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.NullTreatmentClause
	if cached.NullTreatmentClause != nil {
		size += hack.RuntimeAllocSize(int64(1))
	}
	return size
}
func (cached *Limit) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Offset github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Offset.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Rowcount github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Rowcount.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Literal) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Val string
	size += hack.RuntimeAllocSize(int64(len(cached.Val)))
	return size
}
func (cached *LocateExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field SubStr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.SubStr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Str github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Str.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Pos github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Pos.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *LockOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *LockTables) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Tables github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableAndLockTypes
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Tables)) * int64(8))
		for _, elem := range cached.Tables {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *LockingFunc) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Name.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Timeout github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Timeout.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *MatchExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Columns []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Max) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *MemberOfExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Value github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Value.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field JSONArr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.JSONArr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Min) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ModifyColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field NewColDefinition *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnDefinition
	size += cached.NewColDefinition.CachedSize(true)
	// field After *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.After.CachedSize(true)
	return size
}
func (cached *NTHValueExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field N github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.N.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OverClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OverClause
	size += cached.OverClause.CachedSize(true)
	// field FromFirstLastClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.FromFirstLastClause
	if cached.FromFirstLastClause != nil {
		size += hack.RuntimeAllocSize(int64(1))
	}
	// field NullTreatmentClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.NullTreatmentClause
	if cached.NullTreatmentClause != nil {
		size += hack.RuntimeAllocSize(int64(1))
	}
	return size
}
func (cached *NamedWindow) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Windows github.com/xqbumu/sqlparser/dependency/vt/sqlparser.WindowDefinitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Windows)) * int64(8))
		for _, elem := range cached.Windows {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *Nextval) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *NotExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *NtileExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field N github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.N.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OverClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OverClause
	size += cached.OverClause.CachedSize(true)
	return size
}
func (cached *Offset) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Original string
	size += hack.RuntimeAllocSize(int64(len(cached.Original)))
	return size
}
func (cached *OptLike) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field LikeTable github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.LikeTable.CachedSize(false)
	return size
}
func (cached *OrExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Order) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *OrderByOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Cols github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Cols)) * int64(32))
		for _, elem := range cached.Cols {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *OverClause) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field WindowName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.WindowName.CachedSize(false)
	// field WindowSpec *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.WindowSpecification
	size += cached.WindowSpec.CachedSize(true)
	return size
}
func (cached *ParenTableExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Exprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(16))
		for _, elem := range cached.Exprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}

//go:nocheckptr
func (cached *ParsedComments) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field comments github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.comments)) * int64(16))
		for _, elem := range cached.comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	// field _directives github.com/xqbumu/sqlparser/dependency/vt/sqlparser.CommentDirectives
	if cached._directives != nil {
		size += int64(48)
		hmap := reflect.ValueOf(cached._directives)
		numBuckets := int(math.Pow(2, float64((*(*uint8)(unsafe.Pointer(hmap.Pointer() + uintptr(9)))))))
		numOldBuckets := (*(*uint16)(unsafe.Pointer(hmap.Pointer() + uintptr(10))))
		size += hack.RuntimeAllocSize(int64(numOldBuckets * 272))
		if len(cached._directives) > 0 || numBuckets > 1 {
			size += hack.RuntimeAllocSize(int64(numBuckets * 272))
		}
		for k, v := range cached._directives {
			size += hack.RuntimeAllocSize(int64(len(k)))
			size += hack.RuntimeAllocSize(int64(len(v)))
		}
	}
	return size
}
func (cached *ParsedQuery) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Query string
	size += hack.RuntimeAllocSize(int64(len(cached.Query)))
	// field bindLocations []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.bindLocation
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.bindLocations)) * int64(16))
	}
	return size
}
func (cached *PartitionDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Options *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionDefinitionOptions
	size += cached.Options.CachedSize(true)
	return size
}
func (cached *PartitionDefinitionOptions) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field ValueRange *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionValueRange
	size += cached.ValueRange.CachedSize(true)
	// field Comment *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Comment.CachedSize(true)
	// field Engine *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionEngine
	size += cached.Engine.CachedSize(true)
	// field DataDirectory *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.DataDirectory.CachedSize(true)
	// field IndexDirectory *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.IndexDirectory.CachedSize(true)
	// field MaxRows *int
	size += hack.RuntimeAllocSize(int64(8))
	// field MinRows *int
	size += hack.RuntimeAllocSize(int64(8))
	// field TableSpace string
	size += hack.RuntimeAllocSize(int64(len(cached.TableSpace)))
	// field SubPartitionDefinitions github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SubPartitionDefinitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.SubPartitionDefinitions)) * int64(8))
		for _, elem := range cached.SubPartitionDefinitions {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *PartitionEngine) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	return size
}
func (cached *PartitionOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field ColList github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.ColList)) * int64(32))
		for _, elem := range cached.ColList {
			size += elem.CachedSize(false)
		}
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field SubPartition *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SubPartition
	size += cached.SubPartition.CachedSize(true)
	// field Definitions []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Definitions)) * int64(8))
		for _, elem := range cached.Definitions {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *PartitionSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Names github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Partitions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Names)) * int64(32))
		for _, elem := range cached.Names {
			size += elem.CachedSize(false)
		}
	}
	// field Number *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Number.CachedSize(true)
	// field TableName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.TableName.CachedSize(false)
	// field Definitions []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Definitions)) * int64(8))
		for _, elem := range cached.Definitions {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *PartitionValueRange) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Range github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ValTuple
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Range)) * int64(16))
		for _, elem := range cached.Range {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *PerformanceSchemaFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Argument github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Argument.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *PrepareStmt) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Statement github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Statement.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *ReferenceDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field ReferencedTable github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.ReferencedTable.CachedSize(false)
	// field ReferencedColumns github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.ReferencedColumns)) * int64(32))
		for _, elem := range cached.ReferencedColumns {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *RegexpInstrExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Pattern github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Pattern.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Position github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Position.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Occurrence github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Occurrence.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field ReturnOption github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.ReturnOption.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field MatchType github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.MatchType.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *RegexpLikeExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Pattern github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Pattern.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field MatchType github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.MatchType.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *RegexpReplaceExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Pattern github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Pattern.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Repl github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Repl.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Occurrence github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Occurrence.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Position github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Position.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field MatchType github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.MatchType.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *RegexpSubstrExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Pattern github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Pattern.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Occurrence github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Occurrence.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Position github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Position.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field MatchType github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.MatchType.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Release) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *RenameColumn) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field OldName *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.OldName.CachedSize(true)
	// field NewName *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.NewName.CachedSize(true)
	return size
}
func (cached *RenameIndex) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field OldName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.OldName.CachedSize(false)
	// field NewName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.NewName.CachedSize(false)
	return size
}
func (cached *RenameTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field TablePairs []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.RenameTablePair
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TablePairs)) * int64(8))
		for _, elem := range cached.TablePairs {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *RenameTableName) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	return size
}
func (cached *RenameTablePair) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field FromTable github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.FromTable.CachedSize(false)
	// field ToTable github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.ToTable.CachedSize(false)
	return size
}
func (cached *RevertMigration) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field UUID string
	size += hack.RuntimeAllocSize(int64(len(cached.UUID)))
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *SRollback) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *Savepoint) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *Select) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(192)
	}
	// field Cache *bool
	size += hack.RuntimeAllocSize(int64(1))
	// field From []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableExpr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.From)) * int64(16))
		for _, elem := range cached.From {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field SelectExprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.SelectExprs)) * int64(16))
		for _, elem := range cached.SelectExprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Where *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field With *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.With
	size += cached.With.CachedSize(true)
	// field GroupBy github.com/xqbumu/sqlparser/dependency/vt/sqlparser.GroupBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.GroupBy)) * int64(16))
		for _, elem := range cached.GroupBy {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Having *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Where
	size += cached.Having.CachedSize(true)
	// field Windows github.com/xqbumu/sqlparser/dependency/vt/sqlparser.NamedWindows
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Windows)) * int64(8))
		for _, elem := range cached.Windows {
			size += elem.CachedSize(true)
		}
	}
	// field OrderBy github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Limit *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	// field Into *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectInto
	size += cached.Into.CachedSize(true)
	return size
}
func (cached *SelectInto) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field FileName string
	size += hack.RuntimeAllocSize(int64(len(cached.FileName)))
	// field Charset github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnCharset
	size += cached.Charset.CachedSize(false)
	// field FormatOption string
	size += hack.RuntimeAllocSize(int64(len(cached.FormatOption)))
	// field ExportOption string
	size += hack.RuntimeAllocSize(int64(len(cached.ExportOption)))
	// field Manifest string
	size += hack.RuntimeAllocSize(int64(len(cached.Manifest)))
	// field Overwrite string
	size += hack.RuntimeAllocSize(int64(len(cached.Overwrite)))
	return size
}
func (cached *Set) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field Exprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SetExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(8))
		for _, elem := range cached.Exprs {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *SetExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Var *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Variable
	size += cached.Var.CachedSize(true)
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *SetTransaction) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field Characteristics []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Characteristic
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Characteristics)) * int64(16))
		for _, elem := range cached.Characteristics {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	return size
}
func (cached *Show) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Internal github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ShowInternal
	if cc, ok := cached.Internal.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ShowBasic) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Tbl github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Tbl.CachedSize(false)
	// field DbName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.DbName.CachedSize(false)
	// field Filter *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ShowFilter
	size += cached.Filter.CachedSize(true)
	return size
}
func (cached *ShowCreate) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Op github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Op.CachedSize(false)
	return size
}
func (cached *ShowFilter) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Like string
	size += hack.RuntimeAllocSize(int64(len(cached.Like)))
	// field Filter github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Filter.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *ShowMigrationLogs) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field UUID string
	size += hack.RuntimeAllocSize(int64(len(cached.UUID)))
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	return size
}
func (cached *ShowOther) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Command string
	size += hack.RuntimeAllocSize(int64(len(cached.Command)))
	return size
}
func (cached *ShowThrottledApps) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Comments github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Comments
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Comments)) * int64(16))
		for _, elem := range cached.Comments {
			size += hack.RuntimeAllocSize(int64(len(elem)))
		}
	}
	return size
}
func (cached *StarExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field TableName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.TableName.CachedSize(false)
	return size
}
func (cached *Std) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *StdDev) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *StdPop) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *StdSamp) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Stream) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field SelectExpr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectExpr
	if cc, ok := cached.SelectExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	return size
}
func (cached *SubPartition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field ColList github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Columns
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.ColList)) * int64(32))
		for _, elem := range cached.ColList {
			size += elem.CachedSize(false)
		}
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *SubPartitionDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Options *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SubPartitionDefinitionOptions
	size += cached.Options.CachedSize(true)
	return size
}
func (cached *SubPartitionDefinitionOptions) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Comment *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Comment.CachedSize(true)
	// field Engine *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionEngine
	size += cached.Engine.CachedSize(true)
	// field DataDirectory *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.DataDirectory.CachedSize(true)
	// field IndexDirectory *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.IndexDirectory.CachedSize(true)
	// field MaxRows *int
	size += hack.RuntimeAllocSize(int64(8))
	// field MinRows *int
	size += hack.RuntimeAllocSize(int64(8))
	// field TableSpace string
	size += hack.RuntimeAllocSize(int64(len(cached.TableSpace)))
	return size
}
func (cached *Subquery) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Select github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectStatement
	if cc, ok := cached.Select.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *SubstrExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Name.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field From github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.From.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field To github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.To.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Sum) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *TableAndLockType) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableExpr
	if cc, ok := cached.Table.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *TableName) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.Name.CachedSize(false)
	// field Qualifier github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.Qualifier.CachedSize(false)
	return size
}
func (cached *TableOption) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	// field Value *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Literal
	size += cached.Value.CachedSize(true)
	// field String string
	size += hack.RuntimeAllocSize(int64(len(cached.String)))
	// field Tables github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableNames
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Tables)) * int64(32))
		for _, elem := range cached.Tables {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *TableSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field Columns []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColumnDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Columns)) * int64(8))
		for _, elem := range cached.Columns {
			size += elem.CachedSize(true)
		}
	}
	// field Indexes []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IndexDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Indexes)) * int64(8))
		for _, elem := range cached.Indexes {
			size += elem.CachedSize(true)
		}
	}
	// field Constraints []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ConstraintDefinition
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Constraints)) * int64(8))
		for _, elem := range cached.Constraints {
			size += elem.CachedSize(true)
		}
	}
	// field Options github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableOptions
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Options)) * int64(8))
		for _, elem := range cached.Options {
			size += elem.CachedSize(true)
		}
	}
	// field PartitionOption *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.PartitionOption
	size += cached.PartitionOption.CachedSize(true)
	return size
}
func (cached *TablespaceOperation) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *TimestampFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(64)
	}
	// field Name string
	size += hack.RuntimeAllocSize(int64(len(cached.Name)))
	// field Expr1 github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr1.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Expr2 github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr2.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Unit string
	size += hack.RuntimeAllocSize(int64(len(cached.Unit)))
	return size
}
func (cached *TrimFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field TrimArg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.TrimArg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field StringArg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.StringArg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *TruncateTable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	return size
}
func (cached *UnaryExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Union) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectStatement
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectStatement
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field OrderBy github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field With *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.With
	size += cached.With.CachedSize(true)
	// field Limit *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	// field Into *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectInto
	size += cached.Into.CachedSize(true)
	return size
}
func (cached *Update) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(112)
	}
	// field With *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.With
	size += cached.With.CachedSize(true)
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field TableExprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.TableExprs)) * int64(16))
		for _, elem := range cached.TableExprs {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field Exprs github.com/xqbumu/sqlparser/dependency/vt/sqlparser.UpdateExprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Exprs)) * int64(8))
		for _, elem := range cached.Exprs {
			size += elem.CachedSize(true)
		}
	}
	// field Where *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field OrderBy github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderBy)) * int64(8))
		for _, elem := range cached.OrderBy {
			size += elem.CachedSize(true)
		}
	}
	// field Limit *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *UpdateExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Name *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.Name.CachedSize(true)
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *UpdateXMLExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Target github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Target.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field XPathExpr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.XPathExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field NewXML github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.NewXML.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Use) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field DBName github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCS
	size += cached.DBName.CachedSize(false)
	return size
}
func (cached *VStream) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(80)
	}
	// field Comments *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ParsedComments
	size += cached.Comments.CachedSize(true)
	// field SelectExpr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.SelectExpr
	if cc, ok := cached.SelectExpr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Table github.com/xqbumu/sqlparser/dependency/vt/sqlparser.TableName
	size += cached.Table.CachedSize(false)
	// field Where *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Where
	size += cached.Where.CachedSize(true)
	// field Limit *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Limit
	size += cached.Limit.CachedSize(true)
	return size
}
func (cached *Validation) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	return size
}
func (cached *ValuesFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(8)
	}
	// field Name *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ColName
	size += cached.Name.CachedSize(true)
	return size
}
func (cached *VarPop) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *VarSamp) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Variable) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	return size
}
func (cached *Variance) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(16)
	}
	// field Arg github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Arg.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *VindexParam) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Key github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Key.CachedSize(false)
	// field Val string
	size += hack.RuntimeAllocSize(int64(len(cached.Val)))
	return size
}
func (cached *VindexSpec) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field Type github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Type.CachedSize(false)
	// field Params []github.com/xqbumu/sqlparser/dependency/vt/sqlparser.VindexParam
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.Params)) * int64(48))
		for _, elem := range cached.Params {
			size += elem.CachedSize(false)
		}
	}
	return size
}
func (cached *WeightStringFuncExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field As *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.ConvertType
	size += cached.As.CachedSize(true)
	return size
}
func (cached *When) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Cond github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Cond.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Val github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Val.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *Where) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(24)
	}
	// field Expr github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Expr.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
func (cached *WindowDefinition) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(48)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field WindowSpec *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.WindowSpecification
	size += cached.WindowSpec.CachedSize(true)
	return size
}
func (cached *WindowSpecification) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(96)
	}
	// field Name github.com/xqbumu/sqlparser/dependency/vt/sqlparser.IdentifierCI
	size += cached.Name.CachedSize(false)
	// field PartitionClause github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Exprs
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.PartitionClause)) * int64(16))
		for _, elem := range cached.PartitionClause {
			if cc, ok := elem.(cachedObject); ok {
				size += cc.CachedSize(true)
			}
		}
	}
	// field OrderClause github.com/xqbumu/sqlparser/dependency/vt/sqlparser.OrderBy
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.OrderClause)) * int64(8))
		for _, elem := range cached.OrderClause {
			size += elem.CachedSize(true)
		}
	}
	// field FrameClause *github.com/xqbumu/sqlparser/dependency/vt/sqlparser.FrameClause
	size += cached.FrameClause.CachedSize(true)
	return size
}
func (cached *With) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field ctes []*github.com/xqbumu/sqlparser/dependency/vt/sqlparser.CommonTableExpr
	{
		size += hack.RuntimeAllocSize(int64(cap(cached.ctes)) * int64(8))
		for _, elem := range cached.ctes {
			size += elem.CachedSize(true)
		}
	}
	return size
}
func (cached *XorExpr) CachedSize(alloc bool) int64 {
	if cached == nil {
		return int64(0)
	}
	size := int64(0)
	if alloc {
		size += int64(32)
	}
	// field Left github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Left.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	// field Right github.com/xqbumu/sqlparser/dependency/vt/sqlparser.Expr
	if cc, ok := cached.Right.(cachedObject); ok {
		size += cc.CachedSize(true)
	}
	return size
}
